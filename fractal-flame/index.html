<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fractal Flame WebGL</title>
  <style>
    html, body { height: 100%; width: 100%; margin: 0; padding: 0; background: #181c20; }
    body { width: 100vw; height: 100vh; margin: 0; padding: 0; overflow: hidden; }
    canvas { background: #181c20; display: block; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
<canvas id="glcanvas"></canvas>
<script id="frag" type="x-shader/x-fragment">
precision highp float;
uniform float u_time;
uniform vec2 u_res;
// Increased brightness and vibrancy
#define ITER 18
#define ZOOM 1.2
#define BRIGHT 0.09
#define SAT 1.15

vec3 palette(float t) {
  return 0.5 + 0.5*cos(6.2831*(vec3(0.0,0.33,0.67)+t));
}

void main() {
  vec2 uv = (gl_FragCoord.xy - 0.5*u_res) / min(u_res.x, u_res.y) * ZOOM;
  float t = u_time*0.12;
  float a = atan(uv.y, uv.x);
  float r = length(uv);
  float v = 0.0;
  float s = 1.0;
  vec2 z = uv;
  for(int i=0; i<ITER; i++) {
    float k = float(i)*0.15 + t;
    z = abs(z) / dot(z,z) - 0.7 + 0.3*cos(t + k);
    v += exp(-10.0*abs(length(z)-0.5));
    s *= 0.92;
  }
  float cidx = 0.5 + 0.5*sin(3.0*a + t*1.2 + v*0.7);
  vec3 col = palette(cidx);
  col *= v * BRIGHT * SAT;
  col = pow(col, vec3(0.85,0.92,1.0));
  gl_FragColor = vec4(col, 1.0);
}
</script>
<script id="vert" type="x-shader/x-vertex">
attribute vec2 a_pos;
void main() {
  gl_Position = vec4(a_pos,0,1);
}
</script>
<script>
const canvas = document.getElementById('glcanvas');
let gl = canvas.getContext('webgl');
function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  gl.viewport(0,0,canvas.width,canvas.height);
}
window.addEventListener('resize', resize);
resize();
function compile(gl, src, type) {
  let s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)) throw gl.getShaderInfoLog(s);
  return s;
}
function createProgram(gl, vs, fs) {
  let p = gl.createProgram();
  gl.attachShader(p, vs);
  gl.attachShader(p, fs);
  gl.linkProgram(p);
  if(!gl.getProgramParameter(p, gl.LINK_STATUS)) throw gl.getProgramInfoLog(p);
  return p;
}
const vertSrc = document.getElementById('vert').textContent;
const fragSrc = document.getElementById('frag').textContent;
const vs = compile(gl, vertSrc, gl.VERTEX_SHADER);
const fs = compile(gl, fragSrc, gl.FRAGMENT_SHADER);
const prog = createProgram(gl, vs, fs);
gl.useProgram(prog);
// Fullscreen quad
const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
  -1,-1, 1,-1, -1,1, 1,1
]), gl.STATIC_DRAW);
const loc = gl.getAttribLocation(prog, 'a_pos');
gl.enableVertexAttribArray(loc);
gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);
// Uniforms
const u_time = gl.getUniformLocation(prog, 'u_time');
const u_res = gl.getUniformLocation(prog, 'u_res');
function render() {
  gl.uniform1f(u_time, performance.now()*0.001);
  gl.uniform2f(u_res, canvas.width, canvas.height);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  requestAnimationFrame(render);
}
render();
</script>
</body>
</html>
