<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Procedural Terrain: Isometric Flow</title>
  <style>
    html, body { height: 100%; width: 100%; margin: 0; padding: 0; background: #181c20; }
    body { width: 100vw; height: 100vh; margin: 0; padding: 0; overflow: hidden; }
    canvas { background: #181c20; display: block; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <script>
    // Isometric animated terrain with flowing rivers
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    let w, h, tileW, tileH, cols, rows;
    function resize() {
      w = window.innerWidth;
      h = window.innerHeight;
      canvas.width = w;
      canvas.height = h;
      tileW = 32;
      tileH = 16;
  cols = Math.ceil(w / tileW) + 10;
  rows = Math.ceil(h / tileH) + 16;
    }
    window.addEventListener('resize', resize);
    resize();

    // Simplex noise for height
    const grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],[1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],[0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]];
    const p = [];
    for (let i=0; i<256; i++) p[i]=Math.floor(Math.random()*256);
    const perm = [];
    for(let i=0; i<512; i++) perm[i]=p[i & 255];
    function dot(g, x, y) { return g[0]*x+g[1]*y; }
    function noise(xin, yin) {
      let F2 = 0.5*(Math.sqrt(3)-1);
      let s = (xin+yin)*F2;
      let i = Math.floor(xin+s);
      let j = Math.floor(yin+s);
      let G2 = (3-Math.sqrt(3))/6;
      let t = (i+j)*G2;
      let X0 = i-t, Y0 = j-t;
      let x0 = xin-X0, y0 = yin-Y0;
      let i1, j1;
      if(x0>y0){i1=1;j1=0;}else{i1=0;j1=1;}
      let x1 = x0-i1+G2, y1 = y0-j1+G2;
      let x2 = x0-1+2*G2, y2 = y0-1+2*G2;
      let ii = i&255, jj = j&255;
      let gi0 = perm[ii+perm[jj]]%12;
      let gi1 = perm[ii+i1+perm[jj+j1]]%12;
      let gi2 = perm[ii+1+perm[jj+1]]%12;
      let n0, n1, n2;
      n0 = n1 = n2 = 0;
      let t0 = 0.5-x0*x0-y0*y0;
      if(t0>=0){t0 *= t0; n0 = t0 * t0 * dot(grad3[gi0], x0, y0);}
      let t1 = 0.5-x1*x1-y1*y1;
      if(t1>=0){t1 *= t1; n1 = t1 * t1 * dot(grad3[gi1], x1, y1);}
      let t2 = 0.5-x2*x2-y2*y2;
      if(t2>=0){t2 *= t2; n2 = t2 * t2 * dot(grad3[gi2], x2, y2);}
      return 70*(n0+n1+n2);
    }

    // Animate isometric terrain
    let t = 0;
    function draw() {
      ctx.clearRect(0, 0, w, h);
  let scale = 0.13;
  let zscale = 0.24; // slightly reduce exaggeration to avoid overshoot
  // Center the terrain in the viewport, but bias further upward
  let gridW = (cols + rows) * tileW / 2;
  let gridH = (cols + rows) * tileH / 2;
  let xoff = w / 2 + tileW * 2; // shift right
  let yoff = h / 2 - gridH * 0.38; // shift further upward
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          let nx = col * scale;
          let ny = row * scale;
          let hval = noise(nx, ny + t*0.5);
          let z = hval * zscale;
          // Isometric projection
          let isoX = (col - row) * tileW/2 + xoff;
          let isoY = (col + row) * tileH/2 - z * 120 + yoff;
          // Color by height
          let c;
          if (z > 0.5) c = '#eaf7ff'; // snow
          else if (z > 0.2) c = '#b7e3c2'; // hill
          else if (z > -0.1) c = '#6b9e5c'; // grass
          else c = '#2e3d2f'; // ground
          ctx.fillStyle = c;
          ctx.beginPath();
          ctx.moveTo(isoX, isoY);
          ctx.lineTo(isoX + tileW/2, isoY + tileH/2);
          ctx.lineTo(isoX, isoY + tileH);
          ctx.lineTo(isoX - tileW/2, isoY + tileH/2);
          ctx.closePath();
          ctx.fill();
          // Draw river (blue) if height is in a certain range and noise is wavy
          let river = noise(nx+100, ny+100 + t*0.7);
          if (z > -0.05 && z < 0.1 && river > 0.3) {
            ctx.fillStyle = '#4ec3fa';
            ctx.globalAlpha = 0.7;
            ctx.beginPath();
            ctx.moveTo(isoX, isoY);
            ctx.lineTo(isoX + tileW/2, isoY + tileH/2);
            ctx.lineTo(isoX, isoY + tileH);
            ctx.lineTo(isoX - tileW/2, isoY + tileH/2);
            ctx.closePath();
            ctx.fill();
            ctx.globalAlpha = 1.0;
          }
        }
      }
      t += 0.012;
      requestAnimationFrame(draw);
    }
    draw();
  </script>
</body>
</html>
