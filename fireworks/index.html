<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fireworks Animation</title>
  <style>
    html, body { height: 100%; margin: 0; background: #000; overflow: hidden; }
    canvas { display: block; width: 100vw; height: 100vh; }
    .back-link { position: absolute; top: 20px; left: 20px; color: #fff; background: #222a; padding: 8px 16px; border-radius: 6px; text-decoration: none; font-size: 1.1rem; z-index: 10; }
    .back-link:hover { background: #444a; }
  </style>
</head>
<body>
  <canvas id="webgl-canvas"></canvas>
  <script>
const canvas = document.getElementById('webgl-canvas');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
window.addEventListener('resize', () => {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
});
const gl = canvas.getContext('webgl', { alpha: false });
if (!gl) { alert('WebGL not supported'); }

// Vertex shader
const vertSrc = `
attribute vec2 a_position;
attribute float a_pointSize;
attribute vec3 a_color;
varying vec3 v_color;
void main() {
  gl_Position = vec4(a_position, 0, 1);
  gl_PointSize = a_pointSize;
  v_color = a_color;
}`;
// Fragment shader (soft glow)
const fragSrc = `
precision mediump float;
varying vec3 v_color;
void main() {
  float d = length(gl_PointCoord - vec2(0.5));
  float alpha = smoothstep(0.5, 0.2, d);
  gl_FragColor = vec4(v_color, alpha);
}`;
function compileShader(type, src) {
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
    throw new Error(gl.getShaderInfoLog(s));
  }
  return s;
}
const vertShader = compileShader(gl.VERTEX_SHADER, vertSrc);
const fragShader = compileShader(gl.FRAGMENT_SHADER, fragSrc);
const prog = gl.createProgram();
gl.attachShader(prog, vertShader);
gl.attachShader(prog, fragShader);
gl.linkProgram(prog);
gl.useProgram(prog);

// Attributes
const a_position = gl.getAttribLocation(prog, 'a_position');
const a_pointSize = gl.getAttribLocation(prog, 'a_pointSize');
const a_color = gl.getAttribLocation(prog, 'a_color');

// Buffers
const MAX_PARTICLES = 1200;
const posBuf = gl.createBuffer();
const sizeBuf = gl.createBuffer();
const colorBuf = gl.createBuffer();

// Particle system
function randColor() {
  const h = Math.random();
  const s = 0.7 + Math.random() * 0.3;
  const l = 0.5 + Math.random() * 0.2;
  // HSL to RGB
  const a = s * Math.min(l, 1 - l);
  function f(n) {
    const k = (n + h * 12) % 12;
    return l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
  }
  return [f(0), f(8), f(4)];
}
function Firework(x, y) {
  const count = 60 + Math.floor(Math.random() * 40);
  const color = randColor();
  const particles = [];
  for (let i = 0; i < count; ++i) {
    const angle = (2 * Math.PI * i) / count + Math.random() * 0.1;
    const speed = 0.25 + Math.random() * 0.15;
    particles.push({
      x, y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      life: 1,
      color,
      size: 12 + Math.random() * 8
    });
  }
  return particles;
}
let particles = [];
function launchFirework(x, y) {
  particles = particles.concat(Firework(x, y));
  if (particles.length > MAX_PARTICLES) particles = particles.slice(-MAX_PARTICLES);
}
canvas.addEventListener('click', e => {
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) / canvas.width * 2 - 1;
  const y = -((e.clientY - rect.top) / canvas.height * 2 - 1);
  launchFirework(x, y);
});
function randomLaunch() {
  const x = Math.random() * 1.6 - 0.8;
  const y = Math.random() * 0.6 + 0.1;
  launchFirework(x, y);
}
setInterval(randomLaunch, 900);

function render() {
  // Update
  for (let p of particles) {
    p.x += p.vx * 0.016;
    p.y += p.vy * 0.016;
    p.vy -= 0.0007; // gravity
    p.life -= 0.008 + Math.random() * 0.003;
    p.size *= 0.985;
  }
  particles = particles.filter(p => p.life > 0 && p.size > 1);
  // Prepare data
  const pos = [], size = [], color = [];
  for (let p of particles) {
    pos.push(p.x, p.y);
    size.push(p.size);
    color.push(p.color[0], p.color[1], p.color[2]);
  }
  // Draw
  gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
  gl.clear(gl.COLOR_BUFFER_BIT);
  // Position
  gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(pos), gl.DYNAMIC_DRAW);
  gl.enableVertexAttribArray(a_position);
  gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);
  // Size
  gl.bindBuffer(gl.ARRAY_BUFFER, sizeBuf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(size), gl.DYNAMIC_DRAW);
  gl.enableVertexAttribArray(a_pointSize);
  gl.vertexAttribPointer(a_pointSize, 1, gl.FLOAT, false, 0, 0);
  // Color
  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(color), gl.DYNAMIC_DRAW);
  gl.enableVertexAttribArray(a_color);
  gl.vertexAttribPointer(a_color, 3, gl.FLOAT, false, 0, 0);
  // Draw
  gl.drawArrays(gl.POINTS, 0, particles.length);
  requestAnimationFrame(render);
}
render();
</script>
</body>
</html>
