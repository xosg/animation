<html>
<head>
    <title>Crystal Growth Effect</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #181c2b;
            width: 100vw;
            height: 100vh;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>
<body>
<canvas id="crystal"></canvas>
<script>
const canvas = document.getElementById('crystal');
const ctx = canvas.getContext('2d');
let w = window.innerWidth;
let h = window.innerHeight;
canvas.width = w;
canvas.height = h;

const center = { x: w / 2, y: h / 2 };
const crystals = [];
const colors = [
    '#b3e6ff', '#e0f7fa', '#b2ebf2', '#80deea', '#4dd0e1', '#26c6da', '#00bcd4', '#0097a7', '#b2dfdb', '#e1f5fe'
];

function randomColor() {
    return colors[Math.floor(Math.random() * colors.length)];
}

class Crystal {
    constructor(x, y, angle, depth) {
        this.x = x;
        this.y = y;
        this.angle = angle;
        this.length = 0;
        this.maxLength = 40 + Math.random() * 80;
        this.growth = 0.7 + Math.random() * 0.7;
        this.width = 3 + Math.random() * 5 - depth * 0.7;
        this.color = randomColor();
        this.alpha = 0.7 - depth * 0.08;
        this.depth = depth;
        this.children = [];
        this.finished = false;
    }
    update() {
        if (this.length < this.maxLength) {
            this.length += this.growth;
        } else if (!this.finished && this.depth < 4) {
            // Branch out
            let branches = 2 + Math.floor(Math.random() * 2);
            for (let i = 0; i < branches; i++) {
                let branchAngle = this.angle + (Math.random() - 0.5) * Math.PI / (2 + this.depth);
                this.children.push(new Crystal(
                    this.x + Math.cos(this.angle) * this.maxLength,
                    this.y + Math.sin(this.angle) * this.maxLength,
                    branchAngle,
                    this.depth + 1
                ));
            }
            this.finished = true;
        }
        for (let c of this.children) c.update();
    }
    draw(ctx) {
        ctx.save();
        ctx.globalAlpha = this.alpha;
        ctx.strokeStyle = this.color;
        ctx.shadowColor = this.color;
        ctx.shadowBlur = 16 - this.depth * 2;
        ctx.lineWidth = this.width;
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(
            this.x + Math.cos(this.angle) * Math.min(this.length, this.maxLength),
            this.y + Math.sin(this.angle) * Math.min(this.length, this.maxLength)
        );
        ctx.stroke();
        ctx.restore();
        for (let c of this.children) c.draw(ctx);
    }
}

function spawnCrystal() {
    let angle = Math.random() * Math.PI * 2;
    crystals.push(new Crystal(center.x, center.y, angle, 0));
}
for (let i = 0; i < 7; i++) spawnCrystal();

function animate() {
    ctx.clearRect(0, 0, w, h);
    for (let c of crystals) {
        c.update();
        c.draw(ctx);
    }
    requestAnimationFrame(animate);
}

window.addEventListener('resize', () => {
    w = window.innerWidth;
    h = window.innerHeight;
    canvas.width = w;
    canvas.height = h;
    center.x = w / 2;
    center.y = h / 2;
});

animate();
</script>
</body>
</html>
