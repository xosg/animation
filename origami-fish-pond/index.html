<html>
<head>
    <title>Origami Fish Pond Effect</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: linear-gradient(180deg, #b2eaff 0%, #0092ff 100%);
            width: 100vw;
            height: 100vh;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>
<body>
<canvas id="pond"></canvas>
<script>
const canvas = document.getElementById('pond');
const ctx = canvas.getContext('2d');
let w = window.innerWidth;
let h = window.innerHeight;
canvas.width = w;
canvas.height = h;

function randomColor() {
    const colors = [
        '#ffb3b3', '#b3e6ff', '#b3ffd9', '#ffeab3', '#eab3ff', '#b3ffd9', '#b3eaff', '#ffd9b3'
    ];
    return colors[Math.floor(Math.random() * colors.length)];
}

class Fish {
    constructor() {
        this.x = Math.random() * w;
        this.y = h * 0.5 + (Math.random() - 0.5) * h * 0.3;
        this.size = 18 + Math.random() * 18;
        this.color = randomColor();
        this.angle = Math.random() * Math.PI * 2;
        this.speed = 0.7 + Math.random() * 1.2;
        this.wiggle = Math.random() * Math.PI * 2;
        this.wiggleSpeed = 0.08 + Math.random() * 0.06;
        this.targetY = h * 0.5 + (Math.random() - 0.5) * h * 0.3;
    }
    update() {
        this.x += Math.cos(this.angle) * this.speed;
        this.y += Math.sin(this.angle) * this.speed * 0.3;
        this.wiggle += this.wiggleSpeed;
        this.angle += (Math.random() - 0.5) * 0.03;
        // Bounce off edges
        if (this.x < -40) this.x = w + 40;
        if (this.x > w + 40) this.x = -40;
        if (this.y < h * 0.2) this.y = h * 0.2;
        if (this.y > h * 0.8) this.y = h * 0.8;
    }
    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle + Math.sin(this.wiggle) * 0.18);
        ctx.scale(this.size / 30, this.size / 30);
        // Body
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(16, -8);
        ctx.lineTo(24, 0);
        ctx.lineTo(16, 8);
        ctx.closePath();
        ctx.fillStyle = this.color;
        ctx.shadowColor = this.color;
        ctx.shadowBlur = 8;
        ctx.globalAlpha = 0.85;
        ctx.fill();
        // Tail
        ctx.save();
        ctx.rotate(Math.sin(this.wiggle) * 0.7);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(-12, -7);
        ctx.lineTo(-12, 7);
        ctx.closePath();
        ctx.fillStyle = this.color;
        ctx.globalAlpha = 0.6;
        ctx.fill();
        ctx.restore();
        ctx.restore();
    }
}

let fishies = [];
for (let i = 0; i < 14; i++) {
    fishies.push(new Fish());
}

// Ripples
let ripples = [];
function addRipple(x, y) {
    ripples.push({ x, y, r: 1, alpha: 0.5 });
}
canvas.addEventListener('pointerdown', e => {
    addRipple(e.clientX, e.clientY);
});

function drawRipples() {
    ripples = ripples.filter(r => r.alpha > 0.01);
    for (let r of ripples) {
        ctx.save();
        ctx.beginPath();
        ctx.arc(r.x, r.y, r.r, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(180,220,255,' + r.alpha + ')';
        ctx.lineWidth = 2;
        ctx.globalAlpha = r.alpha;
        ctx.shadowColor = '#b2eaff';
        ctx.shadowBlur = 8;
        ctx.stroke();
        ctx.restore();
        r.r += 1.7;
        r.alpha *= 0.96;
    }
}

function animate() {
    ctx.clearRect(0, 0, w, h);
    drawRipples();
    for (let fish of fishies) {
        fish.update();
        fish.draw(ctx);
    }
    requestAnimationFrame(animate);
}

window.addEventListener('resize', () => {
    w = window.innerWidth;
    h = window.innerHeight;
    canvas.width = w;
    canvas.height = h;
});

animate();
</script>
</body>
</html>
