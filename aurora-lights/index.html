<html></html>
<head>
    <title>Aurora Lights Effect</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #0a0a1a;
            width: 100vw;
            height: 100vh;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>
<body>
<canvas id="aurora"></canvas>
<script>
const canvas = document.getElementById('aurora');
const ctx = canvas.getContext('2d');
let w = window.innerWidth;
let h = window.innerHeight;
canvas.width = w;
canvas.height = h;

// Starfield
const stars = [];
for (let i = 0; i < 120; i++) {
    stars.push({
        x: Math.random() * w,
        y: Math.random() * h * 0.7,
        r: 0.5 + Math.random() * 1.2,
        alpha: 0.3 + Math.random() * 0.7,
        tw: Math.random() * Math.PI * 2
    });
}
function drawStars(t) {
    for (let s of stars) {
        ctx.save();
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
        ctx.globalAlpha = s.alpha * (0.7 + 0.3 * Math.sin(t * 0.001 + s.tw));
        ctx.fillStyle = '#fff';
        ctx.shadowColor = '#fff';
        ctx.shadowBlur = 8;
        ctx.fill();
        ctx.restore();
    }
}

// Aurora colors
const auroraColors = [
    [120, 255, 200],
    [80, 200, 255],
    [255, 120, 220],
    [180, 255, 120],
    [120, 220, 255]
];

// Simplex noise for organic waves (2D implementation)
// Adapted from https://github.com/josephg/noisejs
let grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],
    [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],
    [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]];
let p = [];
for (let i=0; i<256; i++) p[i] = Math.floor(Math.random()*256);
let perm = [];
for(let i=0; i<512; i++) perm[i]=p[i & 255];
function dot(g, x, y) { return g[0]*x+g[1]*y; }
function noise(xin, yin) {
    let F2 = 0.5*(Math.sqrt(3)-1);
    let s = (xin+yin)*F2;
    let i = Math.floor(xin+s);
    let j = Math.floor(yin+s);
    let G2 = (3-Math.sqrt(3))/6;
    let t = (i+j)*G2;
    let X0 = i-t, Y0 = j-t;
    let x0 = xin-X0, y0 = yin-Y0;
    let i1, j1;
    if(x0>y0){i1=1;j1=0;} else {i1=0;j1=1;}
    let x1 = x0-i1+G2, y1 = y0-j1+G2;
    let x2 = x0-1+2*G2, y2 = y0-1+2*G2;
    let ii = i & 255, jj = j & 255;
    let gi0 = perm[ii+perm[jj]]%12;
    let gi1 = perm[ii+i1+perm[jj+j1]]%12;
    let gi2 = perm[ii+1+perm[jj+1]]%12;
    let n0, n1, n2;
    n0 = n1 = n2 = 0;
    let t0 = 0.5 - x0*x0-y0*y0;
    if(t0>=0){ t0 *= t0; n0 = t0 * t0 * dot(grad3[gi0], x0, y0); }
    let t1 = 0.5 - x1*x1-y1*y1;
    if(t1>=0){ t1 *= t1; n1 = t1 * t1 * dot(grad3[gi1], x1, y1); }
    let t2 = 0.5 - x2*x2-y2*y2;
    if(t2>=0){ t2 *= t2; n2 = t2 * t2 * dot(grad3[gi2], x2, y2); }
    return 70 * (n0 + n1 + n2);
}

class AuroraLayer {
    constructor(color, y, amp, speed, blur, alpha) {
        this.color = color;
        this.baseY = y;
        this.amp = amp;
        this.speed = speed;
        this.blur = blur;
        this.alpha = alpha;
    }
    draw(ctx, t) {
        ctx.save();
        ctx.beginPath();
        let step = 8;
        for (let x = 0; x <= w; x += step) {
            let n = noise(x * 0.012, t * this.speed + this.baseY * 0.002);
            let y = this.baseY + n * this.amp;
            if (x === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.lineTo(w, h);
        ctx.lineTo(0, h);
        ctx.closePath();
        let grad = ctx.createLinearGradient(0, this.baseY, 0, h);
        grad.addColorStop(0, `rgba(${this.color[0]},${this.color[1]},${this.color[2]},${this.alpha})`);
        grad.addColorStop(1, 'rgba(10,10,26,0)');
        ctx.fillStyle = grad;
        ctx.filter = `blur(${this.blur}px)`;
        ctx.fill();
        ctx.filter = 'none';
        ctx.restore();
    }
}

// Sparkles
const sparkles = [];
function spawnSparkle() {
    if (sparkles.length < 12 && Math.random() < 0.04) {
        sparkles.push({
            x: Math.random() * w,
            y: Math.random() * h * 0.7,
            r: 0.7 + Math.random() * 1.7,
            alpha: 0.7 + Math.random() * 0.3,
            t: 0
        });
    }
}
function drawSparkles(t) {
    for (let i = sparkles.length - 1; i >= 0; i--) {
        let s = sparkles[i];
        s.t += 1;
        ctx.save();
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.r + Math.sin(t*0.01 + s.t)*0.7, 0, Math.PI*2);
        ctx.globalAlpha = s.alpha * (1 - s.t/80);
        ctx.fillStyle = '#fff';
        ctx.shadowColor = '#fff';
        ctx.shadowBlur = 12;
        ctx.fill();
        ctx.restore();
        if (s.t > 80) sparkles.splice(i, 1);
    }
}

let auroraLayers = [
    new AuroraLayer(auroraColors[0], h*0.38, 32, 0.0007, 18, 0.38),
    new AuroraLayer(auroraColors[1], h*0.44, 44, 0.0009, 24, 0.32),
    new AuroraLayer(auroraColors[2], h*0.52, 60, 0.0011, 32, 0.28),
    new AuroraLayer(auroraColors[3], h*0.60, 80, 0.0013, 38, 0.22)
];

function animate(t) {
    ctx.clearRect(0, 0, w, h);
    drawStars(t);
    for (let i = 0; i < auroraLayers.length; i++) {
        auroraLayers[i].draw(ctx, t);
    }
    spawnSparkle();
    drawSparkles(t);
    requestAnimationFrame(animate);
}

window.addEventListener('resize', () => {
    w = window.innerWidth;
    h = window.innerHeight;
    canvas.width = w;
    canvas.height = h;
    // Recreate stars and aurora layers
    stars.length = 0;
    for (let i = 0; i < 120; i++) {
        stars.push({
            x: Math.random() * w,
            y: Math.random() * h * 0.7,
            r: 0.5 + Math.random() * 1.2,
            alpha: 0.3 + Math.random() * 0.7,
            tw: Math.random() * Math.PI * 2
        });
    }
    auroraLayers = [
        new AuroraLayer(auroraColors[0], h*0.38, 32, 0.0007, 18, 0.38),
        new AuroraLayer(auroraColors[1], h*0.44, 44, 0.0009, 24, 0.32),
        new AuroraLayer(auroraColors[2], h*0.52, 60, 0.0011, 32, 0.28),
        new AuroraLayer(auroraColors[3], h*0.60, 80, 0.0013, 38, 0.22)
    ];
});

animate(0);
</script>
</body>
</html>
