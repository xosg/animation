<html>
<head>
    <title>Liquid Mirror Effect</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #181a24;
            width: 100vw;
            height: 100vh;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>
<body>
<canvas id="mirror"></canvas>
<script>
const canvas = document.getElementById('mirror');
const ctx = canvas.getContext('2d');
let w = window.innerWidth;
let h = window.innerHeight;
canvas.width = w;
canvas.height = h;

// Mirror surface parameters
const rows = 80;
const cols = 160;
let points = [];
let mouse = { x: w/2, y: h/2, down: false };

function initPoints() {
    points = [];
    for (let y = 0; y < rows; y++) {
        let row = [];
        for (let x = 0; x < cols; x++) {
            row.push({
                ox: x * w / (cols-1),
                oy: y * h / (rows-1),
                x: x * w / (cols-1),
                y: y * h / (rows-1),
                vy: 0
            });
        }
        points.push(row);
    }
}
initPoints();

function disturb(mx, my, strength) {
    for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
            let p = points[y][x];
            let dx = p.x - mx, dy = p.y - my;
            let dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < 60) {
                p.vy += (Math.cos(dist/60 * Math.PI) + 1) * strength * 0.7;
            }
        }
    }
}

canvas.addEventListener('pointermove', e => {
    mouse.x = e.clientX;
    mouse.y = e.clientY;
    if (mouse.down) disturb(mouse.x, mouse.y, 2.5);
});
canvas.addEventListener('pointerdown', e => {
    mouse.down = true;
    disturb(e.clientX, e.clientY, 4.5);
});
canvas.addEventListener('pointerup', e => { mouse.down = false; });

function updateMirror() {
    for (let y = 1; y < rows-1; y++) {
        for (let x = 1; x < cols-1; x++) {
            let p = points[y][x];
            let avg = (
                points[y-1][x].y + points[y+1][x].y +
                points[y][x-1].y + points[y][x+1].y
            ) / 4;
            let force = (avg - p.y) * 0.18;
            p.vy += force;
            p.vy *= 0.93;
            p.y += p.vy;
            // Pull back to original position
            p.y += (p.oy - p.y) * 0.04;
        }
    }
}

function drawMirror() {
    ctx.clearRect(0, 0, w, h);
    // Draw the wavy surface only (no background gradient)
    ctx.save();
    ctx.globalAlpha = 0.7;
    ctx.strokeStyle = '#eaf6ff';
    ctx.lineWidth = 1.2;
    for (let y = 0; y < rows-1; y++) {
        ctx.beginPath();
        for (let x = 0; x < cols; x++) {
            let p = points[y][x];
            if (x === 0) ctx.moveTo(p.x, p.y);
            else ctx.lineTo(p.x, p.y);
        }
        ctx.stroke();
    }
    ctx.restore();
}

// Automatic alternating mouse slide effect
let autoMouse = {
    x: w/2,
    y: h/2,
    dir: 1,
    t: 0
};

function animate() {
    // Automatic mouse slide from middle left to middle right and back
    autoMouse.t += 0.012;
    let slide = (Math.sin(autoMouse.t) + 1) / 2; // 0 to 1
    autoMouse.x = w * 0.15 + slide * w * 0.7;
    autoMouse.y = h / 2;
    // Simulate disturbance as if mouse is held down
    disturb(autoMouse.x, autoMouse.y, 1.5);
    updateMirror();
    drawMirror();
    requestAnimationFrame(animate);
}

window.addEventListener('resize', () => {
    w = window.innerWidth;
    h = window.innerHeight;
    canvas.width = w;
    canvas.height = h;
    initPoints();
});

animate();
</script>
</body>
</html>
